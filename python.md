# Шпаргалка по python для собеседований

- [Шпаргалка по python для собеседований](#шпаргалка-по-python-для-собеседований)
  - [Базовые знания](#базовые-знания)
    - [Типы данных](#типы-данных)
    - [Truthy and Falsy](#truthy-and-falsy)
      - [int](#int)
      - [float](#float)
      - [str](#str)
      - [bool](#bool)
      - [TODO: Накидать ещё что-нибудь про типы, но вроде нет сильной необходимости](#todo-накидать-ещё-что-нибудь-про-типы-но-вроде-нет-сильной-необходимости)
  - [Декораторы](#декораторы)

## Базовые знания

### Типы данных

Типы данных в python делятся на 2 категории:

- **мутабельные** (*изменяемые*, *mutable*)
- **иммутабельные** (*не изменяемые*, *immutable*)

Раздичие в изменении объекта (очевидно же).

**Immutable objects** - не изменяют своего состояния во времени. При попытки изменения, создаётся (не всегда [см. пример](#example-int-memory)) новый объект.

*Особенности*:

- при изменении обьекта, создаётся новый объект. Существующий никогда не изменяется
- при передачи в качестве аргумента копируется значение, а не ссылка на объект
- Стандартные (built-in) типы:
  - [int](#int)
  - [float](#float)
  - [str](#str)
  - [bool](#bool)
  - tuple (может содержать внутри изменяемые типы данных)
  - namedtuple (аналогично tuple)
  - bytes
  - complex
  - NoneType (singleton)
  - Ellipsis (singleton)
  - frozenset (не уверен)
  - range (интересно, но это знание не имеет сильный вес) )
  - etc.
- Интересные особенности:
  - память под объекты int со значениями от -5 до 259 выделяется 1 раз при запуске интерпритатора и в дальнейшем только присваиваются числа на эти объекты [Пример](#example-int-memory).
  - память под объекты str пытается в оптимизацию, но это происходить далеко не всегда [Пример](#example-str-memory)
  - если внутри кортежа (tuple) есть мутабельный обьект и пользоваться языком неправильно, могут получиться интересные результаты [Пример](#example-tuple-error), Аккуратнее!

<a name="example-int-memory">пример про int</a>

```python
#py3.9.1
a, b = 10, 400

a is (a+1-1)
# >> True

# But!

b is (b+1-1)
# >> False
```

<a name="example-str-memory">пример про str</a>

```python
#py3.9.1
a = "abcd"
b = "abcd"
a is b
# >> True

# But!
a = "Hello, World!"
b = "Hello, World!"
a is b
# >> False!!!

## Be careful!!!

```

<a name="example-tuple-error">пример интересной ошибки</a>

```python
#py3.9.1
a = ([], )
a[0] += [1, 2, 3, 4]
# ERROR!!!
>> TypeError: 'tuple' object does not support item assignment

# But!
a
>> ([1, 2, 3, 4], ) # the object has changed

```

**Mutable objects** - может изменять своё состояние | содержание

*Особенности*:

- можно изменить содержание, при этом объект не изменится.
- все имена (переменные) ссылающиеся на этот объект так же изменят содержания.
- при передачи в качетве аргумента в функцию будет передана ссылка, на тот же обьект, и при изменении обьекта внутри функции глобальный обьект так же поменяется
- Стандартные (built-in) типы:
  - list
  - set
  - dict
  - bytearray
  - object (А вот тут интересно, тип вполне себе мутабельный, при этом имеет перегрузку `__hash__` что делает возможным использовать его и всех его наследников (любой пользовательский класс) в качестве ключа для dict и set)  
  default `__hash__` считается как `id(self)/16`

### Truthy and Falsy

В python есть логический тип данных bool, который имеет только 2 значения (True | Fasle) однако в логических выражениях можно использовать не только его, но и другие типы.

> Тут происходит нечно похожее на неявное приведение типов, но оно достаточно контролируемое (или нет)

По умолчанию объект считается истинным (Truthy), если его класс не определяет метод `__bool__`, возвращающий для объекта False, или метод `__len__`, возвращающий для него ноль.

К Fasle относятся:

- пустой список: `[]`
- пустой кортеж: `()`
- пустой словарь: `{}`
- пустое множество: `set()`
- пустая строка: `""`
- пустой диапазон: `range(0)`
- целочисленный ноль: `0`
- ноль с плавающей точкой: `0.0`
- комплексный ноль: `0j`
- `None`
- `False`

Согласно документации: По умолчанию любой объект имеет истинное значение.



#### int

Тип для целых чисел (integer). Целые числа обладают негораниченной точностью (ограничена только доступной для процесса памятью)

Методы для int представленны в [документации](https://docs.python.org/3/library/stdtypes.html#additional-methods-on-integer-types)

#### float

Тип для чисел с плавающей запятой (вещественные). Обычно реализованны типом double в Си-кишках. чтобы узнать конкретнее `sys.float_info`.  
Для большей точности в стандартных библиотеках реализованы типы

- `fractions.Fraction` - для рациональных дробей.
- `decimal.Decimal` - для чисел с плавающей запятой с пользовательской точностью.

Методы для float представленны в [документации](https://docs.python.org/3/library/stdtypes.html#additional-methods-on-float)

#### str

Строка | текстовая последовательность - тип данных для строковых значений.
Содержит воследовательность unicode (utf-8) символов

Остальное смотри в [документации](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)

#### bool

Логический тип данных, имеет 2 значения:

- True
- Fasle

поддерживает логические операторы:

- or
- and
- not
  
Ну это же булиан, что ты хочешь ещё тут прочитать?  
Если всё же что-то хочешь вот тебе [ссылка на документацию](https://docs.python.org/3/library/functions.html#bool) по функции `bool()`. 

> Найдёшь что-то новое, кидай сюда пул-реквест. )


#### TODO: Накидать ещё что-нибудь про типы, но вроде нет сильной необходимости

## Декораторы

Декоратор - достаточно широкое понятие:  
В архитектурном понимании **Декоратор** - это паттерн проектирования, при использовании которого класс или функция изменяет или дополняет функциональность другого класса или функции без использования наследования или прямого изменения исходного кода.  
В понимании сущностей в python **Декоратор** - это функция или вызываемый объект (далее просто функция-декоратор) которая принимает в качестве параметра другую функцию(исходную), и возвращает новую функцию.

```python
TFunc = Callable[..., Any]

def decorator(func: TFunc) -> TFunc:
   pass
```

```python
# for python 3.10 only

P = ParamSpec("P")
R = TypeVar("R")

def decorator(f: Callable[P, R]) -> Callable[P, Callable[R]]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> R:
        ...
        res = f(*args, **kwargs)
        ...
        return res
    return inner

```

Декораторы используются в самых разных случаях.

*Например*:

- кеширование
- валидация
- логирование вызовов функции
- любая другая мидлварь

```python
# Пример декоратора для логирования вызовов функции
from functools import wraps

def call_log_decorator(logger=None):
    if logger is None:
        logger = print
    
    def decorator(func):
        @wraps(func)
        def inner(*args, **kwargs):
            logger(f"new call {func!r} with {args = } {kwargs = }")
            res = func(*args, **kwargs)
            return res
        return inner
    return decorator
```



