# Шпаргалка по python для собеседований

- [Шпаргалка по python для собеседований](#шпаргалка-по-python-для-собеседований)
  - [Базовые знания](#базовые-знания)
    - [Типы данных](#типы-данных)
    - [Truthy and Falsy](#truthy-and-falsy)
    - [int](#int)
    - [float](#float)
    - [str](#str)
    - [bool](#bool)
    - [TODO: Накидать ещё что-нибудь про типы, но вроде нет сильной необходимости](#todo-накидать-ещё-что-нибудь-про-типы-но-вроде-нет-сильной-необходимости)
    - [Декораторы](#декораторы)
    - [Итератор](#итератор)
    - [Генератор](#генератор)
      - [TODO: yield from](#todo-yield-from)
    - [Классы](#классы)

## Базовые знания

### Типы данных

Типы данных в python делятся на 2 категории:

- **мутабельные** (*изменяемые*, *mutable*)
- **иммутабельные** (*не изменяемые*, *immutable*)

Раздичие в изменении объекта (очевидно же).

**Immutable objects** - не изменяют своего состояния во времени. При попытки изменения, создаётся (не всегда [см. пример](#example-int-memory)) новый объект.

*Особенности*:

- при изменении обьекта, создаётся новый объект. Существующий никогда не изменяется
- при передачи в качестве аргумента копируется значение, а не ссылка на объект
- Стандартные (built-in) типы:
  - [int](#int)
  - [float](#float)
  - [str](#str)
  - [bool](#bool)
  - tuple (может содержать внутри изменяемые типы данных)
  - namedtuple (аналогично tuple)
  - bytes
  - complex
  - NoneType (singleton)
  - Ellipsis (singleton)
  - frozenset (не уверен)
  - range (интересно, но это знание не имеет сильный вес) )
  - etc.
- Интересные особенности:
  - память под объекты int со значениями от -5 до 259 выделяется 1 раз при запуске интерпритатора и в дальнейшем только присваиваются ссылки на эти объекты [Пример](#example-int-memory).
  - память под объекты str пытается в оптимизацию, но это происходить далеко не всегда [Пример](#example-str-memory)
  - если внутри кортежа (tuple) есть мутабельный обьект и пользоваться языком неправильно, могут получиться интересные результаты [Пример](#example-tuple-error), Аккуратнее!

<a name="example-int-memory">пример про int</a>

```python
#py3.9.1
a, b = 10, 400

a is (a+1-1)
# >> True

# But!

b is (b+1-1)
# >> False
```

<a name="example-str-memory">пример про str</a>

```python
#py3.9.1
a = "abcd"
b = "abcd"
a is b
# >> True

# But!
a = "Hello, World!"
b = "Hello, World!"
a is b
# >> False!!!

## Be careful!!!

```

<a name="example-tuple-error">пример интересной ошибки</a>

```python
#py3.9.1
a = ([], )
a[0] += [1, 2, 3, 4]
# ERROR!!!
>> TypeError: 'tuple' object does not support item assignment

# But!
a
>> ([1, 2, 3, 4], ) # the object has changed

```

**Mutable objects** - может изменять своё состояние | содержание

*Особенности*:

- можно изменить содержание, при этом объект не изменится.
- все имена (переменные) ссылающиеся на этот объект так же изменят содержания.
- при передачи в качетве аргумента в функцию будет передана ссылка, на тот же обьект, и при изменении обьекта внутри функции глобальный обьект так же поменяется
- Стандартные (built-in) типы:
  - list
  - set
  - dict
  - bytearray
  - object (А вот тут интересно, тип вполне себе мутабельный, при этом имеет перегрузку `__hash__` что делает возможным использовать его и всех его наследников (любой пользовательский класс) в качестве ключа для dict и set)  
  default `__hash__` считается как `id(self)/16`

### Truthy and Falsy

В python есть логический тип данных bool, который имеет только 2 значения (True | Fasle) однако в логических выражениях можно использовать не только его, но и другие типы.

> Тут происходит нечно похожее на неявное приведение типов, но оно достаточно контролируемое (или нет)

По умолчанию объект считается истинным (Truthy), если его класс не определяет метод `__bool__`, возвращающий для объекта False, или метод `__len__`, возвращающий для него ноль.

К Fasle относятся:

- пустой список: `[]`
- пустой кортеж: `()`
- пустой словарь: `{}`
- пустое множество: `set()`
- пустая строка: `""`
- пустой диапазон: `range(0)`
- целочисленный ноль: `0`
- ноль с плавающей точкой: `0.0`
- комплексный ноль: `0j`
- `None`
- `False`

Согласно документации: По умолчанию любой объект имеет истинное значение.



### int

Тип для целых чисел (integer). Целые числа обладают негораниченной точностью (ограничена только доступной для процесса памятью)

Методы для int представленны в [документации](https://docs.python.org/3/library/stdtypes.html#additional-methods-on-integer-types)

### float

Тип для чисел с плавающей запятой (вещественные). Обычно реализованны типом double в Си-кишках. чтобы узнать конкретнее `sys.float_info`.  
Для большей точности в стандартных библиотеках реализованы типы

- `fractions.Fraction` - для рациональных дробей.
- `decimal.Decimal` - для чисел с плавающей запятой с пользовательской точностью.

Методы для float представленны в [документации](https://docs.python.org/3/library/stdtypes.html#additional-methods-on-float)

### str

Строка | текстовая последовательность - тип данных для строковых значений.
Содержит воследовательность unicode (utf-8) символов

Остальное смотри в [документации](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)

### bool

Логический тип данных, имеет 2 значения:

- True
- Fasle

поддерживает логические операторы:

- or
- and
- not
  
Ну это же булиан, что ты хочешь ещё тут прочитать?  
Если всё же что-то хочешь вот тебе [ссылка на документацию](https://docs.python.org/3/library/functions.html#bool) по функции `bool()`. 

> Найдёшь что-то новое, кидай сюда пул-реквест. )


### TODO: Накидать ещё что-нибудь про типы, но вроде нет сильной необходимости

### Декораторы

Декоратор - достаточно широкое понятие:  
В архитектурном понимании **Декоратор** - это паттерн проектирования, при использовании которого класс или функция изменяет или дополняет функциональность другого класса или функции без использования наследования или прямого изменения исходного кода.  
В понимании сущностей в python **Декоратор** - это функция или вызываемый объект (далее просто функция-декоратор) которая принимает в качестве параметра другую функцию(исходную), и возвращает новую функцию.

```python
TFunc = Callable[..., Any]

def decorator(func: TFunc) -> TFunc:
   pass
```

```python
# for python 3.10 only

P = ParamSpec("P")
R = TypeVar("R")

def decorator(f: Callable[P, R]) -> Callable[P, R]:
    def inner(*args: P.args, **kwargs: P.kwargs) -> R:
        ...
        res = f(*args, **kwargs)
        ...
        return res
    return inner

```

Декораторы используются в самых разных случаях.

*Например*:

- кеширование
- валидация
- логирование вызовов функции
- любая другая мидлварь

*Стандартные (built-in) декораторы python:*

- `staticmethod`
- `classmethod`
- `property`

*Декораторы из стандартной библиотеки:*

- from `functools`:
  - `wraps`
  - `lru_cache`
  - `singledispatchmethod`
  - `cached_property`
- from `typing`:
  - `overload`
  - `final`
- from `abc`:
  - `abstractmethod`
  - `abstractclassmethod`
  - `abstractstaticmethod`
  - `abstractproperty`
- from `dataclasses`:
  - `dataclass`
- etc.

```python
# Пример декоратора для логирования вызовов функции
from typing import (
    Callable,
    Optional,
    TypeVar
)
from functools import wraps

R = TypeVar("R")

def call_log_decorator(
        logger: Optional[Callable[[str], ...]] = None, 
        prefix: Optional[str] = None, 
        postfix: Optional[str] = None
) -> Callable[[Callable[..., R]], ...]:
    """
    Декоратор для логирования вызовов функции
    :param logger: Функция для записи логов
    :param prefix: строка префикса для лог-записи
    :param postfix: строка постфикса для лог-записи
    """
    if logger is None:
        logger = print
    if prefix is None:
        prefix = ''
    if postfix is None:
        postfix = ''

    def decorator(func: Callable[..., R]) -> Callable[..., R]:

        @wraps(func)
        def inner(*args, **kwargs) -> R:
            logger(f"{prefix}new call {func!r} with {args = } {kwargs = }{postfix}")
            res = func(*args, **kwargs)
            return res
        return inner
    return decorator


with open('test_log.log', 'a', encoding='utf8') as logfile:
    @call_log_decorator(logfile.write, postfix='\n')

    def foo(a: int, b: bool) -> str:
        return f"{a = }; {b = }"
```

### Итератор

Тип `Iterator` является обобщением понятия последовательности. 
Объект считается итерируемым, если он физически является последовательностью, либо он является объектом, который воспроизводит по одному результату за раз в контексте инструментов выполнения итераций.

Строго говоря это любой обьект у которого реализован метод `__next__`, а для получения самого итератора у обьекта должен быть реализован метод `__iter__`.

В некотором смысле в категорию итерируемых объектов входят как физические последовательности, это списки, кортежи, диапазоны и т. д. , так и виртуальные последовательности, которые вычисляются по требованию.

Недостаток типа `Iterator` состоит в том, что при первом его вызове вычисляются сразу все значения последовательности как физической, так и виртуальной, к тому же все они хранятся в памяти до их исчерпания. Этот недостаток решает тип [`Generator`](#Генератор) (генератор).

Использовать генератор можено в цекле `for`:

```python
something = ...
my_iterator = iter(something)

for i in my_iterator:
    print(i)
```

Используя функцию `next()`:

```python
something = ...
my_iterator = iter(something)

val_1 = next(my_iterator)
val_2 = next(my_iterator)
val_3 = next(my_iterator)
```

Так же итератор можно привести к типу `list`, тогда он полностью выполнится а результат каждой итерации будет записан в список

```python
>>> it = iter([i*i for i in range(10)])
>>> list(it)
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

## аналогичную функцию можно реализовать самому (но не надо в проекте костылять)
def iter2list(iterator):
    res = []
    for i in iterator:
        res.append(i)
    return res

>>> it = iter([i*i for i in range(10)])
>>> iter2list(it)
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

после того как последовательность в итераторе кончается он выкидывает исключение `StopIteration`

> цикл `for` сам его обратботает, в отличае от функции `next()`

*Итератор не умеет в:*

- слайсы / срезы  
(можно но с помощью `itertools.islice()`, но в этом нет смысла, так как последовательность будет просчитана последовательно)
- не может вернуть длинну последовательности с помощью функции `len()`
- не поддерживает обращение к элементу по индексу

После прохода по последовательности итератор будет пуст:

```python
>>> it = iter([i*i for i in range(10)])
>>> list(it)
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> list(it)
# []
```

**Важно:**
Итератор, не копирует обьект, а лишь ссылается на него. Если изначальеый обьект из которого получен генератор мутабельный, то итератор будет меняться вместе с обьектом:

```python
l = [1, 2, 3, 4]
it = iter(l)

next(it)
# >>> 1

l[1] = 123123

next(it)
# >>> 123123 !!! а не 2, как может показаться
```

### Генератор

Тип `Generator` (генератор) похож на тип `Iterator` (итератор), но тип не хранит значения последовательности в памяти, а генерирует/вычисляет результат на лету - в ходе каждого вызова, тем самым экономит память и вычислительные ресурсы.

*Функция считается генератором, если:*

- Cодержит одно или несколько выражений `yield`.
- При вызове возвращает объект типа `Generator`, но не начнет выполнение.
- Методы `__iter__()` и `__next__()` реализуются автоматически.
- После каждого вызова функция приостанавливается, а управление передается вызывающей стороне.
- Локальные переменные и их состояния запоминаются между последовательными вызовами.
- Когда вычисления заканчиваются по какому то условию, автоматически вызывается исключение `StopIteration`.

Выражение `yield` предоставляют удобный способ реализации протокола итератора, который технически, представляет из себя объект генератора. Это выражение используется в теле функции и приводит к тому, что функция становится генератором. Выражение `yield` используется примерно как `return`, отличие в том, что функция возвращает генератор.

Функции-генераторы так же могут включать инструкцию return, которая завершает генерацию значений, возбуждая исключение `StopIteration` после выполнения обычного выхода из функции. С точки зрения вызывающей программы, метод `generator.__next__()` генератора возобновляет выполнение функции, пока она не встретит следующую инструкцию `yield` или пока не возбудит исключение `StopIteration`.

Выполнение начинается при вызове одного из методов генератора. В это время выполнение переходит к первому выражению `yield`, где он снова приостанавливается, возвращая значение `expression_list`, объекту, вызвавшему генератор. Под приостановкой, подразумевается сохранение всех локальных состояний, включая текущие привязки локальных переменных, указатель инструкции, внутренний стек вычислений и состояние любой обработки исключений.

Когда выполнение возобновляется вызовом одного из методов генератора, то он может действовать точно так же, как если бы выражение `yield` было просто другим внешним вызовом. Значение выражения `yield` после возобновления зависит от метода, который возобновил выполнение. Если используется метод `generator.__next__()` (обычно через `for ... in` или функцию `next()`), то результат отсутствует. В противном случае, если используется метод `generator.send()`, то результатом будет значение, переданное этому методу.

**Расширенная реализация/протокол типа generator.**

- **`generator.__next__():`**:  
Запускает выполнение функции генератора или возобновляет его при последнем выполненном выражении `yield`. Когда функция генератора возобновляется с помощью метода `__ next__()`, текущее выражение `yield` всегда возвращает `None`. Затем выполнение продолжается до следующего выражения `yield`, где генератор снова приостанавливается, а значение `expression_list` возвращается объекту вызвавшему `__next__()`. Если генератор завершает работу без получения другого значения, возникает исключение `StopIteration`.
- **`generator.send(value):`**  
Метод возобновляет выполнение и “отправляет" значение в функцию генератора. Аргумент `value` становится результатом текущего выражения `yield`. Метод `generator.send()` возвращает следующее значение, полученное генератором, или вызывает `StopIteration`, если генератор завершает работу без получения другого значения. Когда `generator.send()` вызывается для запуска генератора, он должен быть вызван с аргументом None, поскольку нет выражения `yield`, которое могло бы получить значение.  
Метод `generator.send(value)` может использоваться, например, чтобы реализовать генератор, который можно будет завершать из вызывающей программы или переустанавливать в нем текущую позицию в последовательности результатов.  
Этот метод обычно вызывается неявно, например, с помощью for ... in цикла или встроенной next() функции.
- **`generator.throw(type[, value[, traceback]]):`**  
Метод вызывает исключение типа `type` в точке, где генератор был приостановлен и возвращает следующее значение, полученное функцией генератора. Если генератор завершает работу без получения другого значения, возникает исключение `StopIteration`. Если функция генератора не ловит переданное исключение или вызывает другое исключение, то это исключение распространяется на вызывающий объект.
- **`generator.close():`**  
Метод вызывает исключение `GeneratorExit` в точке, где функция генератора была приостановлена. Если функция генератора затем завершает работу корректно, уже закрыта или вызывает `GeneratorExit` (не улавливая исключение), `close` возвращается к вызывающему объекту. Если генератор выдает значение, то возникает ошибка `RuntimeError`. Если генератор вызывает любое другое исключение, оно передается вызывающему объекту. Метод `generator.close()` ничего не делает, если генератор уже вышел из-за исключения или нормального выхода.

У Генераторов есть **два** варианта (синтаксиса):
используется для однострочной записи простых последовательностей с 1 выражением (`expression`)

- **Компактный** (аналогинчный `list comperhantion`)  

```python
gen = (i*i for i in range(10))
```

- **в виде функции**

```python
def gen():
    for i in range(10):
        yield i*i
```

#### TODO: yield from

